fn unsign(x: u32) {
    println!(" x : {x}");
}

fn sign(y: i32) {
    println!("y: {y}")
}

fn main() {
    let x = 18;
    let y = 42;

    unsign(x);
    sign(y);
}





















// This slide demonstrates how the Rust compiler infers types based on constraints given by variable declarations and usages.

// It is very important to emphasize that variables declared like this are not of some sort of dynamic “any type” that can hold any data. The machine code generated by such declaration is identical to the explicit declaration of a type. The compiler does the job for us and helps us write more concise code.

// When nothing constrains the type of an integer literal, Rust defaults to i32. This sometimes appears as {integer} in error messages. Similarly, floating-point literals default to f64.